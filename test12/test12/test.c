#define _CRT_SECURE_NO_WARNINGS 1

//1.编写函数： 
//unsigned int reverse_bit(unsigned int value); 
//这个函数的返回 值value的二进制位模式从左到右翻转后的值。 
//
//如： 
//在32位机器上25这个值包含下列各位： 
//00000000000000000000000000011001 
//翻转后：（2550136832） 
//10011000000000000000000000000000 
//程序结果返回： 
//2550136832 
//
//#include <stdio.h>
//#include <math.h>
////（一）通过拿出每一位的二进制数再乘上相应的2的次方，将这些值相加即可得到翻转后的值
//unsigned int reverse(int n) 
//{
//	int i = 0;
//	unsigned int ret = 0;
//	for(i=0; i<32; i++)
//	{
//		ret += (((n>>i)&1) * pow(2,31-i));
//	}
//
//	return ret;
//}
////（二）从后向前每拿出一位或到ret上，ret左移一位
//unsigned int reverse(int n)
//{
//	int i = 0;
//	int ret = 0;
//	for(i=0; i<32; i++)
//	{
//		ret <<=1;
//		ret |= ((n>>i)&1);
//	}
//	00000000 00000000 00000000 00011001  25
//	00000000 00000000 00000000 00000000  0 ret
//	i=0
//	00000000 00000000 00000000 00000000 ret<<=1
//	00000000 00000000 00000000 00000001 (n>>0)&1 拿出最后一位
//	00000000 00000000 00000000 00000001 ret |= ((n>>i)&1)
//	i=1;
//	00000000 00000000 00000000 00000010 ret<<=1
//	00000000 00000000 00000000 00000000 (n>>0)&1 拿出倒数第二位
//	00000000 00000000 00000000 00000010 ret |= ((n>>i)&1)
//	i=2
//	00000000 00000000 00000000 00000100 ret<<=1
//	00000000 00000000 00000000 00000000 (n>>0)&1 拿出倒数第三位
//	00000000 00000000 00000000 00000100 ret |= ((n>>i)&1)
//	i=4
//	00000000 00000000 00000000 00001000 ret<<=1
//	00000000 00000000 00000000 00000001 (n>>0)&1 拿出倒数第四位
//	00000000 00000000 00000000 00001001 ret |= ((n>>i)&1)
//	...
//	以此类推
//	return ret;
//}
//
//int main()
//{
//	int num = 0;
//	unsigned int ret = 0; //不想通过翻转改变原值的符号位
//	printf("请输入要翻转的值：\n");
//	scanf("%d",&num);
//	ret = reverse(num);
//	printf("翻转过后：%u\n",ret);
//	return 0;
//}

//2.不使用（a+b）/2这种方式，求两个数的平均值。 

//#include <stdio.h>
//
//int main()
//{
//	int a = 0;
//	int b = 0;
//	int c = 0;
//	printf("请输入a和b的值：\n");
//	scanf("%d %d",&a,&b);
//	c = (a&b)+((a^b)>>1);
//	//通过a&b找到a和b中二进制位为1的，
//	//然后通过a^b找到a和b中二进制位为0的，向右移动一位，
//	//再把1和0相加，得到的就是两数的平均值
//	//如：a=5  b=9
//	//00000000 00000000 00000000 00000101   5
//	//00000000 00000000 00000000 00001001   9
//	//00000000 00000000 00000000 00000001   5&9
//	//00000000 00000000 00000000 00001110   5^9
//	//00000000 00000000 00000000 00000111   (5^9)>>1
//	//00000000 00000000 00000000 00000111   (5&9)+((5^9)>>1)
//	printf("%d\n",c);
//	return 0;
//}

//3.编程实现： 
//一组数据中只有一个数字出现了一次。其他所有数字都是成对出现的。 
//请找出这个数字。（使用位运算）
//
//#include <stdio.h>
//
//int main()
//{
//	int a[] = {1,3,5,7,9,2,3,5,7,9};
//	int i = 0;
//	int j = 0;
//	int sz = sizeof(a)/sizeof(a[0]);
//	for(i=0; i<sz; i++)
//	{
//		for(j=i+1; j<sz; j++)
//		{
//			if((a[i]^a[j])==0)
//			{
//				a[j]=0;
//				break;
//			}
//		}
//		if((j==sz)&&a[i]!=0)
//		{
//			printf("%d is a single\n",a[i]);
//		}
//	}
//	return 0;
//}
//4. 
//有一个字符数组的内容为:"student a am i",请你将数组的内容改为"i am a student". 
//要求： 
//不能使用库函数。只能开辟有限个空间（空间个数和字符串的长度无关）。
//
//#include <stdio.h>
//#include <assert.h>
//
//int my_strlen(const char*str)
//{
//	int count = 0;
//	assert(str);
//	while(*str++ != '\0')
//	{
//		count++;
//	}
//	return count;
//}
//
//void Move(char arr[],int n)
//{
//	char *p = arr;
//	char *q = arr+n-1;
//	while(p<q)
//	{
//		char tmp = *p;
//		*p = *q;
//		*q = tmp;
//		p++;
//		q--;
//	}
//}
//
//void Show(char arr[],int n)
//{
//	char *left = arr;
//	char *right;
//	int i = 0;
//	while(i<n+1)
//	{
//		if(*arr==' '|| *arr=='\0')
//		{
//			right = arr-1;
//			while(left<right)
//			{
//				char tmp = *left;
//				*left = *right;
//				*right = tmp;
//				left++;
//				right--;
//			}
//			left = arr+1;
//		}
//		arr++;
//		i++;
//	}
//}
//
//int main()
//{
//	char arr[]="student a am I";
//	int sz = my_strlen(arr);
//	Move(arr,sz); //整体翻转
//	Show(arr,sz); //单词翻转
//	printf("%s",arr);
//	return 0;
//}